import numpy as np
import moderngl

from PIL import Image

from manimlib.constants import *
from manimlib.mobject.mobject import Mobject
from manimlib.utils.color import color_to_rgba
from manimlib.utils.images import get_full_raster_image_path
from manimlib.utils.space_ops import normalize_along_axis


class ParametricSurface(Mobject):
    CONFIG = {
        "u_range": (0, 1),
        "v_range": (0, 1),
        "resolution": (100, 100),
        "color": GREY,
        "opacity": 1.0,
        "gloss": 0.3,
        # For du and dv steps.  Much smaller and numerical error
        # can crop up in the shaders.
        "epsilon": 1e-5,
        "render_primative": moderngl.TRIANGLES,
        "vert_shader_file": "surface_vert.glsl",
        "frag_shader_file": "surface_frag.glsl",
        "shader_dtype": [
            ('point', np.float32, (3,)),
            ('du_point', np.float32, (3,)),
            ('dv_point', np.float32, (3,)),
            ('color', np.float32, (4,)),
            ('gloss', np.float32, (1,)),
        ]
    }

    def __init__(self, function=None, **kwargs):
        self.passed_function = function
        super().__init__(**kwargs)

    def uv_func(self, u, v):
        # Typically to be implemented by a subclass
        if self.passed_function is not None:
            return self.passed_function(u, v)
        return [u, v, 0]

    def init_points(self):
        nu, nv = self.resolution
        u_range = np.linspace(*self.u_range, nu + 1)
        v_range = np.linspace(*self.v_range, nv + 1)

        # Get three lists:
        # - Points generated by pure uv values
        # - Those generated by values nudged by du
        # - Those generated by values nudged by dv
        point_lists = []
        for (du, dv) in [(0, 0), (self.epsilon, 0), (0, self.epsilon)]:
            uv_grid = np.array([[[u + du, v + dv] for v in v_range] for u in u_range])
            point_grid = np.apply_along_axis(lambda p: self.uv_func(*p), 2, uv_grid)
            point_lists.append(self.get_triangle_ready_array_from_grid(point_grid))
        # Rather than tracking normal vectors, the points list will hold on to the
        # infinitesimal nudged values alongside the original values.  This way, one
        # can perform all the manipulations they'd like to the surface, and normals
        # are still easily recoverable.
        self.points = np.vstack(point_lists)

    def get_triangle_ready_array_from_grid(self, grid):
        # Given a grid, say of points or normals, this returns an Nx3 array
        # whose rows are elements from this grid in such such a way that successive
        # triplets of points form triangles covering the grid.
        nu, nv, dim = grid.shape
        nu -= 1
        nv -= 1
        arr = np.zeros((nu * nv * 6, dim))
        # To match the triangles covering this surface
        arr[0::6] = grid[:-1, :-1].reshape((nu * nv, dim))  # Top left
        arr[1::6] = grid[+1:, :-1].reshape((nu * nv, dim))  # Bottom left
        arr[2::6] = grid[:-1, +1:].reshape((nu * nv, dim))  # Top right
        arr[3::6] = grid[:-1, +1:].reshape((nu * nv, dim))  # Top right
        arr[4::6] = grid[+1:, :-1].reshape((nu * nv, dim))  # Bottom left
        arr[5::6] = grid[+1:, +1:].reshape((nu * nv, dim))  # Bottom right
        return arr

    def init_colors(self):
        self.set_color(self.color, self.opacity)

    def get_surface_points_and_nudged_points(self):
        k = len(self.points) // 3
        return self.points[:k], self.points[k:2 * k], self.points[2 * k:]

    def get_unit_normals(self):
        s_points, du_points, dv_points = self.get_surface_points_and_nudged_points()
        normals = np.cross(
            (du_points - s_points) / self.epsilon,
            (dv_points - s_points) / self.epsilon,
        )
        return normalize_along_axis(normals, 1)

    def set_color(self, color, opacity=1.0, gloss=None, family=True):
        # TODO, allow for multiple colors
        rgba = color_to_rgba(color, opacity)
        self.rgbas = np.array([rgba])
        if gloss is not None:
            self.set_gloss(gloss)
        if family:
            for submob in self.submobjects:
                submob.set_color(color, opacity, gloss, family)

    def set_opacity(self, opacity, family=True):
        self.rgbas[:, 3] = opacity
        if family:
            for sm in self.submobjects:
                sm.set_opacity(opacity, family)
        return self

    def set_gloss(self, gloss, family=True):
        self.gloss = gloss
        if family:
            for sm in self.submobjects:
                sm.set_gloss(gloss, family)
        return self

    def get_shader_data(self):
        s_points, du_points, dv_points = self.get_surface_points_and_nudged_points()
        data = self.get_blank_shader_data_array(len(s_points))
        data["point"] = s_points
        data["du_point"] = du_points
        data["dv_point"] = dv_points
        self.fill_in_shader_color_info(data)
        return data

    def fill_in_shader_color_info(self, data):
        data["color"] = self.rgbas
        data["gloss"] = self.gloss
        return data


class SGroup(ParametricSurface):
    def __init__(self, *parametric_surfaces, **kwargs):
        super().__init__(**kwargs)
        self.add(*parametric_surfaces)

    def init_points(self):
        pass


class TexturedSurface(ParametricSurface):
    CONFIG = {
        "vert_shader_file": "textured_surface_vert.glsl",
        "frag_shader_file": "textured_surface_frag.glsl",
        "shader_dtype": [
            ('point', np.float32, (3,)),
            ('du_point', np.float32, (3,)),
            ('dv_point', np.float32, (3,)),
            ('im_coords', np.float32, (2,)),
            ('opacity', np.float32, (1,)),
            ('gloss', np.float32, (1,)),
        ]
    }

    def __init__(self, uv_surface, filename, **kwargs):
        if not isinstance(uv_surface, ParametricSurface):
            raise Exception("uv_surface must be of type ParametricSurface")
        path = get_full_raster_image_path(filename)
        self.image = Image.open(path)
        self.texture_path = path
        self.uv_surface = uv_surface
        super().__init__(**kwargs)

    def init_points(self):
        self.points = self.uv_surface.points
        # Init im_coords
        nu, nv = self.uv_surface.resolution
        u_range = np.linspace(0, 1, nu + 1)
        v_range = np.linspace(1, 0, nv + 1)  # Reverse y-direction
        uv_grid = np.array([[[u, v] for v in v_range] for u in u_range])
        self.im_coords = self.uv_surface.get_triangle_ready_array_from_grid(uv_grid)

    def init_colors(self):
        self.opacity = self.uv_surface.rgbas[:, 3]
        self.gloss = self.uv_surface.gloss

    def set_opacity(self, opacity, family=True):
        self.opacity = opacity
        if family:
            for sm in self.submobjects:
                sm.set_opacity(opacity, family)
        return self

    def fill_in_shader_color_info(self, data):
        data["im_coords"] = self.im_coords
        data["opacity"] = self.opacity
        data["gloss"] = self.gloss
        return data
